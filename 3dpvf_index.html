<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-D Velocity Field Visualisation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="wx/js/brain-surface-viewer.js"></script>
    <!-- <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"> -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        accent: '#8B5CF6',
                        dark: '#03080b',            // '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .vector-field-container {
                height: calc(100vh - 8rem);
            }
            .sidebar {
                width: 320px;
                transition: transform 0.3s ease-in-out;
            }
            .sidebar-collapsed {
                transform: translateX(-320px);
            }
            .main-expanded {
                margin-left: 0;
            }
            .panel-gradient {
                background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 100%);
            }
        }
    </style>
</head>
<body class="font-inter bg-dark text-light overflow-hidden">
    <!-- Header -->
    <header class="bg-dark/80 backdrop-blur-md fixed top-0 left-0 right-0 z-50 border-b border-white/10">
        <div class="container mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <button id="sidebar-toggle" class="lg:hidden text-light p-2 rounded-full hover:bg-white/10 transition-colors">
                    <i class="fas fa-bars"></i>
                </button>
                <h1 class="text-xl font-semibold text-light flex items-center gap-2">
                    <i class="fas fa-cube text-primary"></i>
                    <span>3-D Phave Velocity Field</span>
                </h1>
            </div>
            
            <div class="flex items-center gap-4">
                <button id="reset-view" class="text-light/80 hover:text-light transition-colors p-2 rounded-full hover:bg-white/10">
                    <i class="fas fa-redo"></i>
                </button>
                <button id="toggle-fullscreen" class="text-light/80 hover:text-light transition-colors p-2 rounded-full hover:bg-white/10">
                    <i class="fas fa-expand"></i>
                </button>
                <button id="export-data" class="text-light/80 hover:text-light transition-colors p-2 rounded-full hover:bg-white/10">
                    <i class="fas fa-download"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="pt-16 flex h-screen">
        <!-- Sidebar -->
        <aside id="sidebar" class="sidebar fixed left-0 top-16 bottom-0 bg-dark/95 backdrop-blur-md border-r border-white/10 p-2 overflow-y-auto z-40">
            <div class="space-y-6">
                <!-- PVF data Browser -->
                <div class="panel-gradient rounded-xl p-4 border border-white/10">
                <h2 class="text-lg font-medium mb-3 flex items-center gap-2">
                        <i class="fas fa-database text-primary" aria-hidden="True"></i>
                        Database
                </h2>


                <div class="mb-5">
                    <!-- <div>
                        <label class="block text-sm font-medium text-light/80 mb-1">Subject List</label>
                    </div> -->
                    <!-- <div class="relative">
                        <select id="subject-select" class="block w-full bg-gray-50 border border-gray-300 text-gray-900 rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2.5 appearance-none">
                            <option value="">Loading subject names...</option>
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                            <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div> -->
                    <div class="mb-4 gap-2">
                        <label class="block text-sm font-medium text-light/80 mb-3">Subject List</label>
                        <select id="subject-select" class="w-full bg-dark/50 border border-white/10 rounded-lg px-3 py-2 text-light focus:outline-none focus:ring-2 focus:ring-primary/50">
                            <option value="">Loading subject names...</option>
                        </select>
                    </div>
                    <div class="text-sm text-gray-600 gap-2">
                        <button id="load-subject-button" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-2 px-4 transition-colors flex items-center justify-center gap-4" onclick="loadSubjectList()">
                            <i class="fas fa-list"></i>
                            <span>Load Subjects</span>
                        </button>
                    </div>
                </div>

                <!-- File Button -->
                <div class="mb-4 gap-4">
                    <div class="mb-4 gap-2">
                        <label class="block text-sm font-medium text-light/80 mb-3">Meta Data File List</label>
                        <select id="file-select" class="w-full bg-dark/50 border border-white/10 rounded-lg px-3 py-2 text-light focus:outline-none focus:ring-2 focus:ring-primary/50 gap-4">
                            <option value="">Loading files...</option>
                        </select>
                    </div>
                    <div class="text-sm text-gray-600 mb-3">
                        <button id="load-file-button" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-2 px-4 transition-colors flex items-center justify-center gap-4" onclick="loadFile()">
                            <i class="fas fa-file" aria-hidden="true"></i>
                            <span>Load Meta Data Files</span>
                        </button>
                    </div>
                </div>

                <!-- <div class="text-sm text-gray-600">
                    <button id="load-file-button" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-2 px-4 transition-colors flex items-center justify-center gap-4" onclick="loadFile()">Load File</button>
                </div> -->


                <div id="selected-folder-info" class="mt-4 p-3 bg-blue-50 rounded-lg hidden">
                    <h3 class="font-medium text-blue-800">Selected Folder:</h3>
                    <p id="selected-folder-path" class="text-sm text-blue-700"></p>
                </div>
                
                </div>

                <!-- Vector Field Settings -->
                <div class="panel-gradient rounded-xl p-4 border border-white/10">
                    <h2 class="text-lg font-medium mb-3 flex items-center gap-2">
                        <i class="fas fa-sliders-h text-primary"></i>
                        Vector Field Settings
                    </h2>
                    
                    <div class="space-y-4">                        
                        <div>
                            <label class="block text-sm font-medium text-light/80 mb-1">Vector Scale</label>
                            <input type="range" id="vector-scale" min="0.1" max="2" step="0.1" value="1" 
                                class="w-full h-2 bg-white/10 rounded-lg appearance-none cursor-pointer accent-primary">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-light/80 mb-1">Color Scheme</label>
                            <select id="color-scheme" class="w-full bg-dark/50 border border-white/10 rounded-lg px-3 py-2 text-light focus:outline-none focus:ring-2 focus:ring-primary/50">
                                <option value="direction">Direction</option>
                                <option value="temperature">Temperature Map</option>
                                <option value="speed">Speed Magnitude</option>
                                <option value="rainbow">Rainbow</option>
                                <option value="grayscale">Grayscale</option>
                                
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-light/80 mb-1">Vector Display</label>
                            <select id="vector-display" class="w-full bg-dark/50 border border-white/10 rounded-lg px-3 py-2 text-light focus:outline-none focus:ring-2 focus:ring-primary/50">
                                <option value="arrows">Arrows</option>
                                <option value="lines">Lines</option>
                                <option value="tubes">Tubes</option>
                            </select>
                        </div>
                        


                        <label class="block text-sm font-medium text-light/80 mb-1">Show PVF vectors</label>
                        <!-- Present PVF button -->
                        <div class="flex items-center">
                            <button id="present-pvf" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-2 px-4 transition-colors flex items-center justify-left gap-2" onclick="loadPVFVectorField()">
                                <i class="fas fa-long-arrow-right"></i>
                                <span>Present PVF</span>
                            </button>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-light/80 mb-1">Show Grid</label>
                            <div class="flex items-center">
                                <input type="checkbox" id="show-grid" checked 
                                    class="w-4 h-4 text-primary bg-dark/50 border border-white/10 rounded focus:ring-primary/50">
                                <label for="show-grid" class="ml-2 text-sm text-light/80">Display coordinate grid</label>
                            </div>
                        </div>
                    </div>

                </div>
                
                <!-- Streamlines Settings -->
                <div class="panel-gradient rounded-xl p-4 border border-white/10">
                    <h2 class="text-lg font-medium mb-3 flex items-center gap-2">
                        <i class="fas fa-camera text-primary"></i>
                        Streamline settings
                    </h2>
                    
                    <div class="space-y-4">

                        <label class="block text-sm font-medium text-light/80 mb-4">Show Streamlines</label>
                        <div class="flex items-center">
                            <!-- <input type="checkbox" id="show-streamlines" 
                                class="w-4 h-4 text-primary bg-dark/50 border border-white/10 rounded focus:ring-primary/50">
                            <label for="show-streamlines" class="ml-2 text-sm text-light/80">Display particle paths</label> -->
                            <button id="present-streamlines" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-2 px-4 transition-colors flex items-center justify-left gap-2" onclick="createStreamlines()">
                                <i class="fas fa-bars"></i>
                                <span>Present Streamlines</span>
                            </button>
                        </div>
                        </div>
                    
                </div>
                
                <!-- Animation Settings -->
                <div class="panel-gradient rounded-xl p-4 border border-white/10 mb-4">
                    <h2 class="text-lg font-medium mb-3 flex items-center gap-2">
                        <i class="fas fa-play text-primary"></i>
                        Animation
                    </h2>
                    
                    <div class="space-y-6 mb-5">
                        <div>
                            <label class="block text-sm font-medium text-light/80 mb-1">Time Frame</label>
                            <input type="range" id="time-slider" min="0" max="100" value="0" 
                                class="w-full h-2 bg-white/10 rounded-lg appearance-none cursor-pointer accent-primary">
                            <div class="flex justify-between text-xs text-light/60 mt-1">
                                <span id="time-slider-tmin">Tmin=</span>
                                <span id="time-slider-ct">Curr Time=</span>
                                <span id="time-slider-tmax">Tmax=</span>
                            </div>
                        </div>

                        <div style="display: flex; gap: 10px;">
                            <button id="prev-time-point" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-1 px-4 transition-colors flex items-center justify-center gap-4" onclick="prevTimepoint()">
                                <i class="fas fa-long-arrow-left"></i>
                                <span>Prev Time</span>
                            </button>
                            <button id="next-time-point" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-1 px-4 transition-colors flex items-center justify-center gap-4" onclick="nextTimepoint()">
                                <i class="fas fa-long-arrow-right"></i>
                                <span>Next Time</span>
                            </button>
                        </div>

                        <!-- <div>
                            <label class="block text-sm font-medium text-light/80 mb-1">Particles</label>
                            <input type="range" id="particle-count" min="10" max="500" step="10" value="100" 
                                class="w-full h-2 bg-white/10 rounded-lg appearance-none cursor-pointer accent-primary">
                        </div> -->
                        
                        <div class="flex gap-2">
                            <button id="play-pause" class="flex-1 bg-primary hover:bg-primary/80 text-white rounded-lg py-2 px-4 transition-colors flex items-center justify-center gap-2">
                                <i class="fas fa-play"></i>
                                <span>Play</span>
                            </button>
                            <button id="reset-animation" class="flex-1 bg-white/10 hover:bg-white/20 text-light rounded-lg py-2 px-4 transition-colors flex items-center justify-center gap-2">
                                <i class="fas fa-redo"></i>
                                <span>Reset</span>
                            </button>
                        </div>
                    </div>
                    
                </div>


                <!-- Animation Settings -->
                <div class="panel-gradient rounded-xl p-4 border border-white/10 mb-4">
                    <h2 class="text-lg font-medium mb-3 flex items-center gap-2">
                        <i class="fas fa-square text-primary"></i>
                        Console box
                    </h2>
                    
                    <div class="space-y-4 mb-5">
                        <div>
                            <div id="error-message" class="mt-4 p-3 bg-red-50 rounded-lg hidden">
                                <h3 class="font-medium text-blue-800">Message:</h3>
                                <p id="error-details" class="text-sm text-blue-700"></p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Present Streamlines button -->
                    <!-- Present Singularity button -->
                </div>
            </div>
            
        </aside>

        <!-- Visualization Area -->
        <div id="visualization-container" class="flex-1 vector-field-container relative">
            <canvas id="vector-field-canvas"></canvas>
            
            <!-- Loading Indicator -->
            <div id="loading-indicator" class="absolute inset-0 flex items-center justify-center bg-dark/70 backdrop-blur-sm z-30">
                <div class="text-center">
                    <div class="inline-block w-16 h-16 border-4 border-primary/30 border-t-primary rounded-full animate-spin mb-4"></div>
                    <p class="text-light/80">Loading PVF data...</p>
                </div>
            </div>
            
            <!-- Stats Overlay -->
            <div id="stats-overlay" class="absolute bottom-4 right-4 bg-dark/70 backdrop-blur-sm rounded-lg p-3 border border-white/10 text-xs text-light/80">
                <div class="flex items-center gap-2 mb-1">
                    <i class="fas fa-info-circle text-primary"></i>
                    <span class="font-medium">Vector Stats</span>
                </div>
                <div class="space-y-1">
                    <div class="flex justify-between">
                        <span>Resolution:</span>
                        <span id="stats-resolution">8x8x8</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Vectors:</span>
                        <span id="stats-vectors">512</span>
                    </div>
                    <div class="flex justify-between">
                        <span>CondA:</span>
                        <span id="stats-conda">Inf</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Max Magnitude:</span>
                        <span id="stats-max-magnitude">N/A</span>
                    </div>
                    <div class="flex justify-between">
                        <span>FPS:</span>
                        <span id="stats-fps">0</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Mobile Sidebar Overlay -->
    <div id="sidebar-overlay" class="fixed inset-0 bg-black/50 z-30 lg:hidden hidden"></div>

    <script>
        // DOM Elements
        const sidebarToggle          = document.getElementById('sidebar-toggle');
        const sidebar                = document.getElementById('sidebar');
        const sidebarOverlay         = document.getElementById('sidebar-overlay');
        const visualizationContainer = document.getElementById('visualization-container');
        const loadingIndicator       = document.getElementById('loading-indicator');
        const resetViewBtn           = document.getElementById('reset-view');
        const toggleFullscreenBtn    = document.getElementById('toggle-fullscreen');
        const exportDataBtn          = document.getElementById('export-data');
        
        // DOM elements for File Panel
        const folderSelect       = document.getElementById('subject-select');
        const fileSelect         = document.getElementById('file-select');
        const selectedFolderInfo = document.getElementById('selected-folder-info');
        const selectedFolderPath = document.getElementById('selected-folder-path');
        const errorMessage       = document.getElementById('error-message');
        const errorDetails       = document.getElementById('error-details');

        // time slider elements
        const timeSliderTMin        = document.getElementById('time-slider-tmin');
        const timeSliderTMax        = document.getElementById('time-slider-tmax');
        const timeSliderCurrentTime = document.getElementById('time-slider-ct');
        const timeSlider            = document.getElementById('time-slider');

        // brainbrowser viewer
        // BrainBrowser.config.set("worker_dir", "build/brainbrowser-2.5.2/workers");
        // let viewer = new BrainSurfaceViewer();
        
        // PVF variables
        let subject_ID          = "";
        let PVF_dimension       = 50;
        let PVF_times           = [];
        let PVF_num_time_points = 100;
        let PVF_positions       = [];
        let PVF_directions      = [];
        let PVF_streamlines     = {};
        let PVF_condA_data      = {};
        let PVF_condA           = 0;
        let PVF_pattern_data    = {};
        

        let volume_size         = 50;       // where brain, vectors and streamlines reside
        let streamlineWidth     = 0.1;      // 0.025 streamline tube width
        let streamlinesGroup    = new THREE.Group();
        let present_PVF         = false;
        let present_streamlines = false;

        // GUI parameters
        t_min             = 0
        t_max             = 99
        current_timepoint = 0

        // Three.js Scene Variables
        let scene, camera, renderer, controls;
        let vectorField   = [];
        let vectorObjects = [];
        let particles     = [];
        let gridHelper;
        let animationId;
        let isAnimating = false;
        let lastTime    = 0;
        let fps         = 0;
        
        // Settings
        let settings = {
            fieldType: 'random',
            resolution: 20,
            vectorScale: 0.8,
            showGrid: false,
            colorScheme: 'direction',
            vectorDisplay: 'arrows',
            showStreamlines: true,
            animationSpeed: 1,
            particleCount: 100
        };
        
        // Initialize the application
        function init() {
            // Setup sidebar toggle
            sidebarToggle.addEventListener('click', toggleSidebar);
            sidebarOverlay.addEventListener('click', toggleSidebar);
            
            // Setup event listeners for settings changes
            setupSettingsListeners();
            
            // Setup Three.js scene
            setupThreeJS();
            
            // BrainBrowser.SurfaceViewer.start("brainbrowser", function(viewer) {

            //     //Add an event listener.
            //     viewer.addEventListener("displaymodel", function() {
            //         console.log("We have a model!");
            //     });

            //     // Start rendering the scene.
            //     viewer.render();

            //     // Load a model into the scene.
            //     viewer.loadModelFromURL("/models/brain_surface.obj");

            //     // Hook viewer behaviour into UI.
            //     $("#wireframe").change(function(e) {
            //         viewer.setWireframe($(this).is(":checked"));
            //     });

            // });
            // Create vector objects
            createVectorObjects();
            
            // Setup stats
            updateStats();
            
            // Start animation loop
            animate();
            
            // // Hide loading indicator
            setTimeout(() => {
                loadingIndicator.classList.add('opacity-0');
                setTimeout(() => {
                    loadingIndicator.classList.add('hidden');
                }, 300);
            }, 800);

            loadSubjectList();
        }
        
        // Toggle sidebar
        function toggleSidebar() {
            sidebar.classList.toggle('sidebar-collapsed');
            sidebarOverlay.classList.toggle('hidden');
        }
        
        // Setup Three.js scene
        function setupThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x03080b); // THREE.Color(0x1E293B);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(
                60, 
                visualizationContainer.clientWidth / visualizationContainer.clientHeight, 
                0.1, 
                1000
            );
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('vector-field-canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(visualizationContainer.clientWidth, visualizationContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            
            // Add grid helper
            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
            scene.add(gridHelper);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.addEventListener('change', () => {
                // Update stats when camera moves
                updateStats();
            });
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Reset view button
            resetViewBtn.addEventListener('click', resetView);
            
            // Toggle fullscreen button
            toggleFullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // Export data button
            exportDataBtn.addEventListener('click', exportVectorFieldData);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = visualizationContainer.clientWidth / visualizationContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(visualizationContainer.clientWidth, visualizationContainer.clientHeight);
        }
        
        // Reset camera view
        function resetView() {
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }
        
        // Toggle fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        
        // Setup settings listeners
        function setupSettingsListeners() {
            // // Field type
            // document.getElementById('field-type').addEventListener('change', (e) => {
            //     settings.fieldType = e.target.value;
            //     regenerateVectorField();
            // });
            
            // // Resolution
            // document.getElementById('resolution').addEventListener('input', (e) => {
            //     settings.resolution = parseInt(e.target.value);
            //     regenerateVectorField();
            // });
            timeSlider.min                  = t_min;
            timeSlider.max                  = t_max;
            const times_tmin        = t_min;
            const times_tmax        = t_max;
            const times_currenttime = 0;
            timeSliderTMax.innerHTML = "Tmax=" + times_tmax.toFixed(2);
            timeSliderTMin.innerHTML = "Tmin=" + times_tmin.toFixed(2);
            timeSliderCurrentTime.innerHTML = "Curr Time=" + times_currenttime.toFixed(2);
            
            // Vector scale
            document.getElementById('vector-scale').addEventListener('input', (e) => {
                settings.vectorScale = parseFloat(e.target.value);
                updateVectorObjects();
            });
            
            // Show grid
            document.getElementById('show-grid').addEventListener('change', (e) => {
                settings.showGrid = e.target.checked;
                gridHelper.visible = settings.showGrid;
            });
            
            // Color scheme
            document.getElementById('color-scheme').addEventListener('change', (e) => {
                settings.colorScheme = e.target.value;
                updateVectorObjects();
            });
            
            // Vector display
            document.getElementById('vector-display').addEventListener('change', (e) => {
                settings.vectorDisplay = e.target.value;
                updateVectorObjects();
            });


            document.getElementById('time-slider').addEventListener('change', (e) => {
                current_timepoint               = e.target.value;
                const times_currenttime = PVF_times[current_timepoint];
                timeSliderCurrentTime.innerHTML = "Curr Time=" + times_currenttime.toFixed(2);
                updatePVFStreamlines();
                showError(current_timepoint)
                // updateVectorObjects();
            });
            
            // // Show streamlines
            // document.getElementById('show-streamlines').addEventListener('change', (e) => {
            //     settings.showStreamlines = e.target.checked;
            //     if (settings.showStreamlines) {
            //         createParticles();
            //     } else {
            //         removeParticles();
            //     }
            // });
            
            // Animation speed
            // document.getElementById('animation-speed').addEventListener('input', (e) => {
            //     settings.animationSpeed = parseFloat(e.target.value);
            // });
            
            // // Particle count
            // document.getElementById('particle-count').addEventListener('input', (e) => {
            //     settings.particleCount = parseInt(e.target.value);
            //     if (settings.showStreamlines) {
            //         createParticles();
            //     }
            // });
            
            // Play/pause animation
            document.getElementById('play-pause').addEventListener('click', toggleAnimation);
            
            // Reset animation
            document.getElementById('reset-animation').addEventListener('click', resetAnimation);
        }


        function loadSurface(viewer) {
            // load brain surface left hemisphere
            viewer.loadSurfaceFromURL("pvf_data/fs_subjects/sub-003/surf/lh.pial.obj", {
                success: () => {
                viewer.setSurfaceColor("#e0e0e0");
                viewer.setSurfaceOpacity(0.5);
                viewer.resetView();
                }
            });
            // load brain surface right hemisphere
            viewer.loadSurfaceFromURL("pvf_data/fs_subjects/sub-003/surf/rh.pial.obj", {
                success: () => {
                viewer.setSurfaceColor("#e0e0e0");
                viewer.setSurfaceOpacity(0.5);
                viewer.resetView();
                }
            });
        }


        // load PVF vector field
        function loadPVFVectorField() {
            vectorField = [];
            settings.resolution = PVF_dimension;
            const size = PVF_dimension;
            const spacing = volume_size / (size - 1);
            // Show loading indicator            
            loadingIndicator.classList.remove('hidden', 'opacity-0');


             for (let i = 0; i < PVF_positions.length; i++) {
                // vector position
                const x = PVF_positions[i][0];
                const y = PVF_positions[i][1];
                const z = PVF_positions[i][2];
                // vector direction
                vx = PVF_directions[i][0];
                vy = PVF_directions[i][1];
                vz = PVF_directions[i][2];

                const magnitude = Math.sqrt(vx * vx + vy * vy + vz * vz);
                if (magnitude > 0) {
                    vx /= magnitude;
                    vy /= magnitude;
                    vz /= magnitude;
                }
            
                vectorField.push({
                    position: new THREE.Vector3(x, y, z),
                    direction: new THREE.Vector3(vx, vy, vz),
                    magnitude: magnitude
                });
             }


            createVectorObjects()
            // Update controls
            controls.update();
            
            // loadingIndicator.classList.remove('hidden', 'opacity-0');
            
            // Render scene
            renderer.render(scene, camera);
            
            // showError("PVF vector field loaded successfully");
            // Hide loading indicator
            loadingIndicator.classList.add('opacity-0', 'hidden');
            present_PVF = true;
        }


        async function updatePVFStreamlines() {
            // loadingIndicator.classList.remove('hidden', 'opacity-0');
            subject = folderSelect.value;
            file = fileSelect.value;
            const response = await fetch(`http://localhost:3000/api/update-PVF-streamlines?subject=${encodeURIComponent(subject)}&file=${encodeURIComponent(file)}&timepoint=${current_timepoint}`);
                
            if (!response.ok) {
                const errorData = await response.json().catch(() => null);
                throw new Error(errorData?.error || `Failed to load folders (${response.status})`);
            }
            
            const data = await response.json();
            PVF_positions    = data.pvf_positions;
            PVF_directions   = data.pvf_directions;
            PVF_times        = data.times;
            PVF_condA        = data.condA;
            PVF_pattern_data = data.patterns;
            PVF_streamlines  = data.streamlines;

            // Update PVF vectors
            if (present_PVF == true){
                removeVectorObjects();
                loadPVFVectorField();
            };

            // Update streamlines
            if (present_streamlines == true){
                // removeStreamlines();
                createStreamlines();
            };
            // loadingIndicator.classList.add('hidden', 'opacity-0');
        };


        // Generate vector field based on settings
        function generateVectorField() {
            vectorField = [];
            const size = settings.resolution;
            const spacing = 100 / (size - 1);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    for (let k = 0; k < size; k++) {
                        // Calculate position
                        const x = i * spacing - 10;
                        const y = j * spacing - 10;
                        const z = k * spacing - 10;
                        
                        // Calculate vector based on field type
                        let vx, vy, vz;
                        
                        switch (settings.fieldType) {
                            case 'random':
                                vx = Math.random() * 2 - 1;
                                vy = Math.random() * 2 - 1;
                                vz = Math.random() * 2 - 1;
                                break;
                                
                            case 'curl':
                                // Curl field example: v = (-y, x, 0)
                                vx = -y;
                                vy = x;
                                vz = 0;
                                break;
                                
                            case 'divergence':
                                // Divergent field example: v = (x, y, z)
                                vx = x;
                                vy = y;
                                vz = z;
                                break;
                                
                            case 'vortex':
                                // Vortex field
                                const r = Math.sqrt(x * x + y * y) + 0.1;
                                vx = -y / r;
                                vy = x / r;
                                vz = 0;
                                break;
                                
                            case 'custom':
                                // Custom field - could be modified based on user input
                                vx = PVF_Vx[i][j][k];
                                vy = PVF_Vy[i][j][k];
                                vz = PVF_Vz[i][j][k];
                                break;
                        }
                        
                        // Normalize vector
                        const magnitude = Math.sqrt(vx * vx + vy * vy + vz * vz);
                        if (magnitude > 0) {
                            vx /= magnitude;
                            vy /= magnitude;
                            vz /= magnitude;
                        }
                        
                        vectorField.push({
                            position: new THREE.Vector3(x, y, z),
                            direction: new THREE.Vector3(vx, vy, vz),
                            magnitude: magnitude
                        });
                    }
                }
            }
        }
        
        // Regenerate vector field and update visualization
        function regenerateVectorField() {
            // Show loading indicator
            loadingIndicator.classList.remove('hidden', 'opacity-0');
            
            // Remove existing vector objects
            removeVectorObjects();
            
            // Generate new vector field
            // generateVectorField();
            loadPVFVectorField();
            
            // Create new vector objects
            createVectorObjects();
            
            // Update particles if needed
            if (settings.showStreamlines) {
                createParticles();
            }
            
            // Update stats
            updateStats();

            loadingIndicator.classList.add('hidden', 'opacity-0');
            // // Hide loading indicator
            // setTimeout(() => {
            //     loadingIndicator.classList.add('opacity-0');
            //     setTimeout(() => {
            //         loadingIndicator.classList.add('hidden');
            //     }, 300);
            // }, 500);
        }
        
        // Create vector objects in the scene
        function createVectorObjects() {
            // Clear existing vector objects
            removeVectorObjects();
            
            // Create new vector objects based on settings
            const scale = settings.vectorScale;
            
            vectorField.forEach(vector => {
                let vectorObject;
                
                switch (settings.vectorDisplay) {
                    case 'arrows':
                        // Create arrow helper for each vector
                        const arrowHelper = new THREE.ArrowHelper(
                            vector.direction.clone().multiplyScalar(scale),
                            vector.position,
                            1.5 * scale,
                            getVectorColor(vector)
                        );
                        vectorObject = arrowHelper;
                        break;
                        
                    case 'lines':
                        // Create line for each vector
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            vector.position,
                            vector.position.clone().add(vector.direction.clone().multiplyScalar(1.5 * scale))
                        ]);
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: getVectorColor(vector),
                            linewidth: 2
                        });
                        vectorObject = new THREE.Line(lineGeometry, lineMaterial);
                        break;
                        
                    case 'tubes':
                        // Create tube for each vector
                        const tubeGeometry = new THREE.CylinderGeometry(
                            0.05 * scale, 0.15 * scale, 1.5 * scale, 12
                        );
                        const tubeMaterial = new THREE.MeshStandardMaterial({
                            color: getVectorColor(vector),
                            roughness: 0.8,
                            metalness: 0.2
                        });
                        vectorObject = new THREE.Mesh(tubeGeometry, tubeMaterial);
                        
                        // Position and orient the tube
                        vectorObject.position.copy(vector.position);
                        vectorObject.position.add(vector.direction.clone().multiplyScalar(0.75 * scale));
                        
                        const quaternion = new THREE.Quaternion();
                        quaternion.setFromUnitVectors(
                            new THREE.Vector3(0, 1, 0),
                            vector.direction.clone().normalize()
                        );
                        vectorObject.setRotationFromQuaternion(quaternion);
                        break;
                }
                
                scene.add(vectorObject);
                vectorObjects.push(vectorObject);
            });
        }
        
        // Update existing vector objects
        function updateVectorObjects() {
            const scale = settings.vectorScale;
            
            vectorField.forEach((vector, index) => {
                const vectorObject = vectorObjects[index];
                
                // Update color
                if (vectorObject.material) {
                    if (vectorObject.material.color) {
                        vectorObject.material.color.set(getVectorColor(vector));
                    }
                } else if (vectorObject.setColor) {
                    vectorObject.setColor(getVectorColor(vector));
                }
                
                // Update scale and position based on display type
                switch (settings.vectorDisplay) {
                    case 'arrows':
                        vectorObject.setLength(1.5 * scale, 0.2 * scale, 0.1 * scale);
                        break;
                        
                    case 'lines':
                        vectorObject.geometry.setFromPoints([
                            vector.position,
                            vector.position.clone().add(vector.direction.clone().multiplyScalar(1.5 * scale))
                        ]);
                        break;
                        
                    case 'tubes':
                        vectorObject.scale.set(1, 1.5 * scale, 1);
                        vectorObject.position.copy(vector.position);
                        vectorObject.position.add(vector.direction.clone().multiplyScalar(0.75 * scale));
                        break;
                }
            });
        }
        
        // Remove vector objects from the scene
        function removeVectorObjects() {
            vectorObjects.forEach(object => {
                scene.remove(object);
                // while (object.children.length > 0) {
                //     scene.remove(object.children[0]);
                // }
                if (object.geometry) object.geometry.dispose();
                if (object.material) object.material.dispose();
            });
            vectorObjects = [];
        }
        
        // Get color for a vector based on settings
        function getVectorColor(vector) {
            const magnitude = vector.magnitude;
            
            switch (settings.colorScheme) {
                case 'speed':
                    // Color based on magnitude (speed)
                    return new THREE.Color().setHSL(0.4 - (magnitude / 5), 1, 0.5);
                    
                case 'direction':
                    // Color based on direction
                    return new THREE.Color().setHSL(
                        (Math.atan2(vector.direction.z, vector.direction.x) + Math.PI) / (2 * Math.PI),
                        1,
                        0.5 + (vector.direction.y + 1) / 4
                    );
                    
                case 'temperature':
                    // Temperature map (blue to red)
                    return new THREE.Color().setHSL(0.6 - (magnitude / 10), 1, 0.5);
                    
                case 'rainbow':
                    // Rainbow colors based on position
                    return new THREE.Color().setHSL(
                        (vector.position.x + 10) / 40 + 
                        (vector.position.y + 10) / 40 + 
                        (vector.position.z + 10) / 40,
                        1,
                        0.5
                    );
                    
                case 'grayscale':
                    // Grayscale based on magnitude
                    return new THREE.Color().setRGB(
                        0.3 + (magnitude / 5),
                        0.3 + (magnitude / 5),
                        0.3 + (magnitude / 5)
                    );
            }
        }
        
        // Create particles for streamlines
        function createParticles() {
            // Remove existing particles
            removeParticles();
            
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(settings.particleCount * 3);
            
            // Initialize particles at random positions
            for (let i = 0; i < settings.particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = Math.random() * 20 - 10;  // x
                positions[i3 + 1] = Math.random() * 20 - 10;  // y
                positions[i3 + 2] = Math.random() * 20 - 10;  // z
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.15,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Store particles with their trail history
            particles.trailHistory = [];
            for (let i = 0; i < settings.particleCount; i++) {
                particles.trailHistory.push([]);
            }
            
            particles.trailLines = [];
            
            this.particles = particles;
        }
        
        // Remove particles from the scene
        function removeParticles() {
            if (this.particles) {
                scene.remove(this.particles);
                this.particles.geometry.dispose();
                this.particles.material.dispose();
                
                // Remove trail lines
                if (this.particles.trailLines) {
                    this.particles.trailLines.forEach(line => {
                        scene.remove(line);
                        line.geometry.dispose();
                        line.material.dispose();
                    });
                }
                
                this.particles = null;
            }
        }
        
        // Update particles position based on vector field
        function updateParticles(deltaTime) {
            if (!this.particles || !settings.showStreamlines) return;
            
            const particles = this.particles;
            const positions = particles.geometry.attributes.position.array;
            const speedFactor = settings.animationSpeed * deltaTime;
            
            // Update each particle position
            for (let i = 0; i < settings.particleCount; i++) {
                const i3 = i * 3;
                const x = positions[i3];
                const y = positions[i3 + 1];
                const z = positions[i3 + 2];
                
                // Find nearest vector in the field
                const nearestVector = findNearestVector(x, y, z);
                
                // Get direction from nearest vector
                const direction = nearestVector.direction.clone();
                
                // Update position
                positions[i3] += direction.x * speedFactor;
                positions[i3 + 1] += direction.y * speedFactor;
                positions[i3 + 2] += direction.z * speedFactor;
                
                // Wrap around if particle goes outside bounds
                if (positions[i3] > 10) positions[i3] = -10;
                if (positions[i3] < -10) positions[i3] = 10;
                if (positions[i3 + 1] > 10) positions[i3 + 1] = -10;
                if (positions[i3 + 1] < -10) positions[i3 + 1] = 10;
                if (positions[i3 + 2] > 10) positions[i3 + 2] = -10;
                if (positions[i3 + 2] < -10) positions[i3 + 2] = 10;
                
                // Update trail history
                const trailHistory = particles.trailHistory[i];
                trailHistory.push(new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]));
                
                // Limit trail length
                if (trailHistory.length > 30) {
                    trailHistory.shift();
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Update trail lines
            updateTrailLines();
        }
        
        // Update trail lines for particles
        function updateTrailLines() {
            if (!this.particles) return;
            
            const particles = this.particles;
            
            // Remove old trail lines
            particles.trailLines.forEach(line => {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            particles.trailLines = [];
            
            // Create new trail lines
            for (let i = 0; i < settings.particleCount; i++) {
                const trailHistory = particles.trailHistory[i];
                
                if (trailHistory.length > 1) {
                    const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailHistory);
                    const trailMaterial = new THREE.LineBasicMaterial({
                        color: new THREE.Color().setHSL(i / settings.particleCount, 1, 0.5),
                        transparent: true,
                        opacity: 0.6
                    });
                    const trailLine = new THREE.Line(trailGeometry, trailMaterial);
                    scene.add(trailLine);
                    particles.trailLines.push(trailLine);
                }
            }
        }
        
        // Find nearest vector in the field to a given position
        function findNearestVector(x, y, z) {
            let nearestVector = vectorField[0];
            let minDistance = Infinity;
            
            vectorField.forEach(vector => {
                const distance = Math.sqrt(
                    Math.pow(x - vector.position.x, 2) +
                    Math.pow(y - vector.position.y, 2) +
                    Math.pow(z - vector.position.z, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestVector = vector;
                }
            });
            
            return nearestVector;
        }
        
        // Toggle animation
        function toggleAnimation() {
            isAnimating = !isAnimating;
            const playPauseBtn = document.getElementById('play-pause');
            
            if (isAnimating) {
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i><span>Pause</span>';
                if (settings.showStreamlines && !this.particles) {
                    createParticles();
                }
            } else {
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i><span>Play</span>';
            }
        }
        
        // Reset animation
        function resetAnimation() {
            if (this.particles) {
                const positions = this.particles.geometry.attributes.position.array;
                
                // Reset particles to random positions
                for (let i = 0; i < settings.particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] = Math.random() * 20 - 10;  // x
                    positions[i3 + 1] = Math.random() * 20 - 10;  // y
                    positions[i3 + 2] = Math.random() * 20 - 10;  // z
                    
                    // Clear trail history
                    this.particles.trailHistory[i] = [];
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
                
                // Remove trail lines
                if (this.particles.trailLines) {
                    this.particles.trailLines.forEach(line => {
                        scene.remove(line);
                        line.geometry.dispose();
                        line.material.dispose();
                    });
                    this.particles.trailLines = [];
                }
            }
        }
        
        // Update stats display
        function updateStats() {
            document.getElementById('stats-resolution').textContent = 
                `${settings.resolution}x${settings.resolution}x${settings.resolution}`;
            
            document.getElementById('stats-vectors').textContent = 
                vectorField.length;
            
            // Calculate max magnitude
            const maxMagnitude = vectorField.reduce((max, vector) => {
                return Math.max(max, vector.magnitude);
            }, 0);

            document.getElementById('stats-max-magnitude').textContent = 
                maxMagnitude.toFixed(2);
            
            document.getElementById('stats-conda').textContent = 
                PVF_condA.toFixed(2);
            
            document.getElementById('stats-fps').textContent = 
                Math.round(fps);
        }
        
        // Export vector field data
        function exportVectorFieldData() {
            // Prepare data in a format suitable for export
            const exportData = {
                settings: settings,
                vectors: vectorField.map(vector => {
                    return {
                        position: {
                            x: vector.position.x,
                            y: vector.position.y,
                            z: vector.position.z
                        },
                        direction: {
                            x: vector.direction.x,
                            y: vector.direction.y,
                            z: vector.direction.z
                        },
                        magnitude: vector.magnitude
                    };
                })
            };
            
            // Create JSON blob
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            
            // Create download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `vector-field-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        }
        
        // Animation loop
        function animate(timestamp) {
            // Calculate FPS
            if (lastTime) {
                const delta = timestamp - lastTime;
                fps = 1000 / delta;
            }
            lastTime = timestamp;
            
            // Update controls
            controls.update();
            
            // Update particles if animation is enabled
            if (isAnimating) {
                updateParticles(0.016); // Assuming ~60fps
            }
            
            // Render scene
            renderer.render(scene, camera);
            
            // Continue animation loop
            animationId = requestAnimationFrame(animate);
        }
        
        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
        // 
        
        // Clean up when window is closed
        window.addEventListener('beforeunload', () => {
            cancelAnimationFrame(animationId);
            if (renderer) {
                renderer.dispose();
            }
        });
        
        // streamlines
        /**
         */
        function createStreamlines() {
            // 
            // 
            streamlinesGroup.clear();
            // streamlinesGroup = new THREE.Group();
            streamlinesGroup.name = 'PVFstreamlines';
            scene.add(streamlinesGroup);

            // 
            const startColor = new THREE.Color(0xff0000); // 
            const endColor = new THREE.Color(0x0000ff);   // 

            num_streamlines = PVF_streamlines.length;
            showError(`Number of streamlines: ${num_streamlines}`)

            
            for (i=0; i < num_streamlines; i++){
                // 1. RK4
                const streamline_points = PVF_streamlines[i];

                const points = [];
                for (j=0; j < streamline_points.length; j++){
                    points.push(new THREE.Vector3(streamline_points[j][0], streamline_points[j][1], streamline_points[j][2]));
                }
                // 
                if (points.length < 5) return;

                // 2. 
                const curve = new THREE.CatmullRomCurve3(points);
                
                // 
                const geometry = new THREE.TubeGeometry(
                    curve,
                    60,  // 
                    streamlineWidth,  // 
                    8,   // 
                    false  // 
                );

                // 
                const colors = [];
                for (let i = 0; i < geometry.attributes.position.count; i++) {
                    // 01
                    const t = i / (geometry.attributes.position.count - 1);
                    // 
                    const color = startColor.clone().lerp(endColor, t);
                    colors.push(color.r, color.g, color.b);
                }

                // 
                geometry.setAttribute(
                    'color',
                    new THREE.BufferAttribute(new Float32Array(colors), 3)
                );

                // 
                const material = new THREE.MeshBasicMaterial({
                    vertexColors: THREE.VertexColors,  // 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.85
                });

                // 
                const streamline = new THREE.Mesh(geometry, material);
                streamlinesGroup.add(streamline);
            };

            // 4. 
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            // 
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            // showError("Streamlines created successfully.");
            present_streamlines = true;
        };

        // subject
        async function loadSubjectList(path = '') {
            try {
                // 
                folderSelect.innerHTML = '<option value="">Loading subject names...</option>';
                hideError();
                
                // API
                const response = await fetch(`http://localhost:3000/api/list-subjects`);
                
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    throw new Error(errorData?.error || `Failed to load subject names (${response.status})`);
                }
                
                const data = await response.json();

                folderSelect.innerHTML = '';

                
                for (const key in data) {
                    // console.log(key, data[key]);
                    const option = document.createElement('option');
                    option.value = data[key];
                    option.textContent = data[key];
                    folderSelect.appendChild(option);
                }

                
                // 
                if (Object.keys(data).length === 0) {
                    const noFolderOption = document.createElement('option');
                    noFolderOption.value = '';
                    noFolderOption.textContent = 'No metadata Json files found';
                    noFolderOption.disabled = true;
                    folderSelect.appendChild(noFolderOption);
                }
                
            } catch (error) {
                console.error('Error loading subject names:', error);
                showError(error.message);
                folderSelect.innerHTML = '<option value="">Failed to load subject names</option>';
            }
        }

        // 
        async function loadFileList(subject) {
            // 
            console.log(`Load files for subject: ${subject}`);
            try {
                // 
                fileSelect.innerHTML = '<option value="">Loading Files...</option>';
                hideError();
                
                // API
                const response = await fetch(`http://localhost:3000/api/list-subjects-files?subject=${encodeURIComponent(subject)}`);
                
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    throw new Error(errorData?.error || `Failed to load files (${response.status})`);
                }
                
                const data = await response.json();

                // console.log(Object.keys(data).length);
                console.log(data);
                // 
                fileSelect.innerHTML = '';
                
                for (const key in data) {
                    // console.log(key, data[key]);
                    const option = document.createElement('option');
                    option.value = data[key];
                    option.textContent = data[key];
                    fileSelect.appendChild(option);
                }

                
                // 
                if (Object.keys(data).length === 0) {
                    const noFolderOption = document.createElement('option');
                    noFolderOption.value = '';
                    noFolderOption.textContent = 'No folders found';
                    noFolderOption.disabled = true;
                    fileSelect.appendChild(noFolderOption);
                }
                
            } catch (error) {
                console.error('Error loading folders:', error);
                showError(error.message);
                folderSelect.innerHTML = '<option value="">Failed to load folders</option>';
            }
        }


        // previous timepoint
        async function prevTimepoint() {
            if (current_timepoint > t_min){
                current_timepoint -= 1;
                timeSlider.value = current_timepoint;
                const times_currenttime = PVF_times[current_timepoint];
                updatePVFStreamlines();
                timeSliderCurrentTime.innerHTML = "Curr Time=" + times_currenttime.toFixed(2);
            }
        };
        
        // previous timepoint
        async function nextTimepoint() {
            if (current_timepoint < t_max && current_timepoint + 1 <= t_max){
                current_timepoint += 1;
                timeSlider.value = current_timepoint;
                const times_currenttime = PVF_times[current_timepoint];
                updatePVFStreamlines();
                timeSliderCurrentTime.innerHTML = "Curr Time=" + times_currenttime.toFixed(2);
            }
        };

        async function loadFile() {
            // 
            loadingIndicator.classList.remove('hidden', 'opacity-0');
            subject = folderSelect.value;
            file    = fileSelect.value;
            const response = await fetch(`http://localhost:3000/api/load-subjects-files?subject=${encodeURIComponent(subject)}&file=${encodeURIComponent(file)}`);
                
            if (!response.ok) {
                const errorData = await response.json().catch(() => null);
                throw new Error(errorData?.error || `Failed to load folders (${response.status})`);
            }
            
            const data = await response.json();
            subject_ID          = data.subject_ID;
            PVF_positions       = data.pvf_positions;
            PVF_directions      = data.pvf_directions;
            PVF_times           = data.times;
            PVF_condA           = data.condA;
            PVF_pattern_data    = data.patterns;
            PVF_streamlines     = data.streamlines;
            PVF_num_time_points = data.PVF_num_time_points;
            PVF_dimension       = data.PVF_dimension;
            t_max               = PVF_num_time_points - 1;
            // console.log(`PVF_num_time_points: ${PVF_times}`);
            timeSlider.min           = t_min;
            timeSlider.max           = t_max;
            timeSlider.value         = current_timepoint;
            const times_tmin        = PVF_times[t_min];
            const times_tmax        = PVF_times[t_max];
            const times_currenttime = PVF_times[timeSlider.value];
            timeSliderTMax.innerHTML = "Tmax=" + times_tmax.toFixed(2);
            timeSliderTMin.innerHTML = "Tmin=" + times_tmin.toFixed(2);
            timeSliderCurrentTime.innerHTML = "Curr Time=" + times_currenttime.toFixed(2);

            showError("PVF and streamlines loaded successfully.");
            loadingIndicator.classList.add('hidden', 'opacity-0');
            
        }

        // 
        function showError(message) {
            errorDetails.textContent = message;
            errorMessage.classList.remove('hidden');
        }
        
        // 
        function hideError() {
            errorMessage.classList.add('hidden');
        }
        
        // 
        function showSelectedFolder(path) {
            if (path) {
                selectedFolderPath.textContent = path;
                selectedFolderInfo.classList.remove('hidden');
            } else {
                selectedFolderInfo.classList.add('hidden');
            }
        }

        // 
        folderSelect.addEventListener('change', (e) => {
            const selectedSubject = e.target.value;
            // showSelectedFolder(selectedSubject);
            loadFileList(selectedSubject);
            
            // 
            // loadSubjectList(selectedPath);
        });
    </script>
</body>
</html>